package detectmotion.test;

import org.opencv.core.*;
import org.opencv.tracking.MultiTracker;
import org.opencv.video.BackgroundSubtractorMOG2;
import org.opencv.videoio.VideoCapture;
import java.util.ArrayList;
import java.util.List;

import static org.opencv.imgproc.Imgproc.*;
import static org.opencv.video.Video.createBackgroundSubtractorMOG2;
import static org.opencv.highgui.HighGui.*;

/**
 * @author ：tyy
 * @date ：Created in 2020/4/27 21:07
 * @description：
 * @modified By：
 * @version: $
 */
public class MyTracker{
    BackgroundSubtractorMOG2 pMOG2;
    VideoCapture capture;
    MyTracker(String videoFilename){
         pMOG2 = createBackgroundSubtractorMOG2(200, 36.0, true); //进行提取背景
         //pMOG2.setVarThreshold(20);
         capture = new VideoCapture(videoFilename);
    }


    void process()
    {
        if (!capture.isOpened())
        {
            return;
        }

        // Current frame
        Mat frame = new Mat();
        // Foreground mask generated by MOG2 method
        Mat fgMaskMOG2 = new Mat();
        // MOG2 Background subtractor
        while (capture.read(frame))
        {
            Mat result = frame.clone();
            pMOG2.apply(frame,fgMaskMOG2,-1);//读出前景目标图像

            imshow("掩码之前",fgMaskMOG2);//
            //对前景先进行中值滤波，再进行形态学膨胀操作，以去除伪目标和连接断开的小目标
             medianBlur(fgMaskMOG2, fgMaskMOG2, 5);
            //morphologyEx(mask, mask, MORPH_DILATE, getStructuringElement(MORPH_RECT, Size(5, 5)));
            //测试：先开运算再闭运算
            morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_CLOSE, getStructuringElement(MORPH_RECT,new Size(5, 5)));
            morphologyEx(fgMaskMOG2, fgMaskMOG2, MORPH_OPEN, getStructuringElement(MORPH_RECT, new Size(5, 5)));


            List<MatOfPoint> contours  = new ArrayList<>();
            Mat s = new Mat();
            findContours(fgMaskMOG2,contours,s,RETR_EXTERNAL,CHAIN_APPROX_NONE);
            if (contours.size() < 1) continue;
            contours.sort((MatOfPoint p2,MatOfPoint p1)->{
                return  p1.rows()*p1.cols() - p2.rows()*p2.rows();
            });


            for (int i = 0; i < contours.size(); i++)
             {
                //当第i个连通分量的外接矩阵面积小于最大面积的1/6，则认为是伪目标
                if (contourArea(contours.get(i)) < contourArea(contours.get(0)) / 5)
                          break;
                 //包含轮廓的最小矩阵
                 Rect rct = boundingRect(contours.get(i));
                 rectangle(result, rct.tl(),rct.br(),new  Scalar(0, 255, 0), 2);

             }

            imshow("最后处理结果", result);
            waitKey(30);


        }
    }
    static {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
    }
    public static void main(String[] args) {
        String path = Thread.currentThread().getContextClassLoader().getResource("tese.mp4").getPath();//获取资源路径
        new MyTracker(path).process();


    }

}